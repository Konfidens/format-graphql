{"version":3,"file":"formatSdl.js","names":["sortSchema","key","value","options","sortArguments","sortDefinitions","sortFields","slice","sort","a","b","nonNamedKinds","includes","kind","name","localeCompare","walkAST","node","nextKey","arguments","definitions","fields","Array","isArray","map","child","schemaSdl"],"sources":["../../src/utilities/formatSdl.js"],"sourcesContent":["// @flow\n\nimport {\n  print,\n  parse,\n} from 'graphql';\nimport type {ASTNode} from 'graphql';\nimport {getOptions} from './optionalize';\nimport type {OptionsType} from './optionalize';\n\nconst sortSchema = (key, value, options: OptionsType) => {\n  const {\n    sortArguments,\n    sortDefinitions,\n    sortFields,\n  } = options;\n\n  if (\n    sortDefinitions && key === 'definitions' ||\n    sortFields && key === 'fields' ||\n    sortArguments && key === 'arguments'\n  ) {\n    return value.slice().sort((a, b) => {\n      const nonNamedKinds = ['SchemaDefinition', 'SchemaExtension'];\n      if (nonNamedKinds.includes(a.kind)) {\n        return -1;\n      }\n\n      if (nonNamedKinds.includes(b.kind)) {\n        return 1;\n      }\n\n      return a.name.value.localeCompare(b.name.value);\n    });\n  }\n\n  return value;\n};\n\n/**\n * We only care about rearranging:\n * - definitions\n * - fields\n * - arguments\n *\n * A GraphQL Schema AST looks something like this:\n *\n *   {\n *     \"definitions\": [\n *       {\n *         fields: [\n *           {\n *             arguments: [\n *               ...\n *             ]\n *           }\n *           ...\n *         ],\n *       },\n *       ...\n *     ]\n *   }\n *\n * Note that there are no cycles -  we don't need to recurse through the whole\n * AST. There's a finite nest depth of 3 node types for us to walk down:\n *\n *   <start> -> definitions -> fields -> arguments\n */\nconst walkAST = (node: ASTNode, options: OptionsType, key: ?string) => {\n  // Map a node type to the child node type we should walk down next\n  const nextKey = {\n    arguments: null,\n    definitions: 'fields',\n    fields: 'arguments',\n  };\n\n  if (!key) {\n    return node;\n  }\n\n  if (!Array.isArray(node[key])) {\n    return node;\n  }\n\n  node[key] = sortSchema(key, node[key], options).map((child) => {\n    return walkAST(child, options, nextKey[key]);\n  });\n\n  return node;\n};\n\nexport default (schemaSdl: string, options?: $Shape<OptionsType>): string => {\n  return print(walkAST(parse(schemaSdl), getOptions(options), 'definitions'));\n};\n"],"mappings":";;;;;;;AAEA;;AAKA;;AAGA,MAAMA,UAAU,GAAG,CAACC,GAAD,EAAMC,KAAN,EAAaC,OAAb,KAAsC;EACvD,MAAM;IACJC,aADI;IAEJC,eAFI;IAGJC;EAHI,IAIFH,OAJJ;;EAMA,IACEE,eAAe,IAAIJ,GAAG,KAAK,aAA3B,IACAK,UAAU,IAAIL,GAAG,KAAK,QADtB,IAEAG,aAAa,IAAIH,GAAG,KAAK,WAH3B,EAIE;IACA,OAAOC,KAAK,CAACK,KAAN,GAAcC,IAAd,CAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAU;MAClC,MAAMC,aAAa,GAAG,CAAC,kBAAD,EAAqB,iBAArB,CAAtB;;MACA,IAAIA,aAAa,CAACC,QAAd,CAAuBH,CAAC,CAACI,IAAzB,CAAJ,EAAoC;QAClC,OAAO,CAAC,CAAR;MACD;;MAED,IAAIF,aAAa,CAACC,QAAd,CAAuBF,CAAC,CAACG,IAAzB,CAAJ,EAAoC;QAClC,OAAO,CAAP;MACD;;MAED,OAAOJ,CAAC,CAACK,IAAF,CAAOZ,KAAP,CAAaa,aAAb,CAA2BL,CAAC,CAACI,IAAF,CAAOZ,KAAlC,CAAP;IACD,CAXM,CAAP;EAYD;;EAED,OAAOA,KAAP;AACD,CA3BD;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMc,OAAO,GAAG,CAACC,IAAD,EAAgBd,OAAhB,EAAsCF,GAAtC,KAAuD;EACrE;EACA,MAAMiB,OAAO,GAAG;IACdC,SAAS,EAAE,IADG;IAEdC,WAAW,EAAE,QAFC;IAGdC,MAAM,EAAE;EAHM,CAAhB;;EAMA,IAAI,CAACpB,GAAL,EAAU;IACR,OAAOgB,IAAP;EACD;;EAED,IAAI,CAACK,KAAK,CAACC,OAAN,CAAcN,IAAI,CAAChB,GAAD,CAAlB,CAAL,EAA+B;IAC7B,OAAOgB,IAAP;EACD;;EAEDA,IAAI,CAAChB,GAAD,CAAJ,GAAYD,UAAU,CAACC,GAAD,EAAMgB,IAAI,CAAChB,GAAD,CAAV,EAAiBE,OAAjB,CAAV,CAAoCqB,GAApC,CAAyCC,KAAD,IAAW;IAC7D,OAAOT,OAAO,CAACS,KAAD,EAAQtB,OAAR,EAAiBe,OAAO,CAACjB,GAAD,CAAxB,CAAd;EACD,CAFW,CAAZ;EAIA,OAAOgB,IAAP;AACD,CArBD;;mBAuBgBS,S,EAAmBvB,O,KAA0C;EAC3E,OAAO,oBAAMa,OAAO,CAAC,oBAAMU,SAAN,CAAD,EAAmB,6BAAWvB,OAAX,CAAnB,EAAwC,aAAxC,CAAb,CAAP;AACD,C"}